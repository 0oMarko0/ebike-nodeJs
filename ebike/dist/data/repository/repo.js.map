{"version":3,"file":"repo.js","sourceRoot":"","sources":["../../../src/data/repository/repo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Collection, ObjectId } from \"mongodb\";\nimport MongoDB from \"../database/mongo\";\nimport _ from \"lodash\";\nimport moment = require(\"moment\");\nimport logger from \"../../utils/logger\";\n\nexport default class Repo {\n    private readonly collection: Collection;\n\n    constructor(collection: string) {\n        this.collection = MongoDB.getDb().collection(collection);\n    }\n\n    getCollection(): Collection {\n        return this.collection;\n    }\n\n    async create(document: any): Promise<string> {\n        Object.assign(document, { created: moment().unix() });\n        const result = await this.collection.insertOne(document);\n        if (!result.insertedId) throw new Error(`Unable to insert document ${document}`);\n\n        return result.insertedId.toString();\n    }\n\n    async getById(id: string, projection?: any, customAggregation?: any) {\n        const query = { _id: this.toObjectId(id) };\n\n        const aggregation: any = [\n            {\n                $match: query,\n            },\n        ];\n\n        if (_.isArray(customAggregation) && !_.isEmpty(customAggregation)) {\n            aggregation.push(...customAggregation);\n        }\n\n        if (projection) {\n            aggregation.push({ $project: projection });\n        }\n        return this.collection.aggregate(aggregation).next();\n    }\n\n    async update(id: string, document: any): Promise<ObjectId> {\n        const query = { _id: this.toObjectId(id) };\n        Object.assign(document, { updated: moment().unix() });\n        const update = {\n            $set: this.stripDocument(document),\n        };\n\n        const result = await this.collection.updateOne(query, update);\n        if (result.matchedCount === 0) throw new Error(`Unable to update document: ${document}`);\n\n        return this.toObjectId(id);\n    }\n\n    async delete(id: string) {\n        const query = { _id: this.toObjectId(id) };\n        const result = await this.collection.deleteOne(query);\n        if (result.deletedCount === 0) throw new Error(`Unable to delete document with id: ${id}`);\n    }\n\n    async drop() {\n        try {\n            await this.collection.drop();\n        } catch (e) {\n            logger.error(`Mongo Error: ${e.codeName}`);\n        }\n    }\n\n    private toObjectId(id: string | ObjectId): ObjectId {\n        if (_.isString(id) && ObjectId.isValid(id)) {\n            return new ObjectId(id);\n        }\n\n        return <ObjectId>id;\n    }\n\n    private stripDocument(document: any) {\n        if (_.has(document, 'id')) delete document[\"id\"];\n        if(_.has(document, '_id')) delete document[\"_id\"];\n\n        return document;\n    }\n}\n"]}